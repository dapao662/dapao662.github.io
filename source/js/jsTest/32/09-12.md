---
title: 9--12例子
date: 2020-10-31 18:12:30
tag: js
---

### 9、Function.prototype.call()

>于`call`唯一不同的是，`call()`方法接受的是一个参数列表
```js
Function.prototype.call = function(context = window, ...args) {
    if (typeof this !== 'function') {
        throw new TypeError('Type Error');
    }
    //ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名
    const fn = Symbol('fn');
    context[fn] = this;

    const res = context[fn](...args);
    delete context[fn];
    return res;
}
```


### 10、Function.prototype.bind
```js
Function.prototype.bind = function (context, ...args) {
    if (typeof this !== 'function') {
        throw new Error('Type Error');
    }
    //保存this的值
    var self = this;

    return function F() {
        //考虑new的情况
        if(this instanceof F) {
            return new self(...args, ...arguments);
        }
        return self.apply(context, [...args, ...arguments]);
    }
}

```

### 11、debounce（防抖）
>触发高频时间后n秒内函数只会执行一次,如果n秒内高频时间再次触发,则重新计算时间。

```js
const debounce = (fn, time) => {
    let timeout = null;
    return function() {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            fn.apply(this, arguments);
        }, time);
    }
};
```
>防抖常应用于用户进行搜索输入节约请求资源，`window`触发`resize`事件时进行防抖只触发一次。

### 12、throttle（节流）
>高频时间触发,但n秒内只会执行一次,所以节流会稀释函数的执行频率。

```js
const throttle = (fn, time) => {
    let flag = true;
    return function () {
        if(!flag) {
            return ;
        }
        flag = false;
        setTimeout(() => {
            fn.apply(this, arguments);
            flag = true;
        }, time);
    }
}
```
>节流常应用于鼠标不断点击触发、监听滚动事件。

